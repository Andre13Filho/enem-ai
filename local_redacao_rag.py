#!/usr/bin/env python3
"""
Sistema RAG Local para Professora Carla - Reda√ß√£o
Utiliza √≠ndices FAISS pr√©-constru√≠dos e baixados do Hugging Face.
"""

import streamlit as st
import os
import requests
import re
import tempfile
from typing import Dict, List, Any, Optional
from datetime import datetime

# Importa√ß√µes para processamento de PDF
try:
    import PyPDF2
    import fitz  # PyMuPDF
    PDF_AVAILABLE = True
except ImportError:
    PDF_AVAILABLE = False
    st.warning("‚ö†Ô∏è Bibliotecas de PDF n√£o instaladas. Execute: pip install PyPDF2 PyMuPDF")

# LangChain imports
from langchain_community.vectorstores import FAISS
try:
    from langchain_huggingface import HuggingFaceEmbeddings
except ImportError:
    from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain.schema import Document
from langchain.chains import ConversationalRetrievalChain
try:
    from langchain_community.memory import ConversationBufferMemory
except ImportError:
    from langchain.memory import ConversationBufferMemory
from langchain.llms.base import LLM
from langchain.callbacks.manager import CallbackManagerForLLMRun

# Groq para LLM
from groq import Groq

# Diret√≥rios para armazenar os √≠ndices FAISS
FAISS_INDEX_DIR = "faiss_index_redacao"
FAISS_SUCCESS_INDEX_DIR = "faiss_index_success_redacao"

class GroqLLM(LLM):
    """LLM personalizado para DeepSeek R1 Distill via Groq"""
    
    api_key: str
    model_name: str = "deepseek-r1-distill-llama-70b"
    
    class Config:
        arbitrary_types_allowed = True
    
    def __init__(self, api_key: str, **kwargs):
        super().__init__(api_key=api_key, model_name="deepseek-r1-distill-llama-70b", **kwargs)
    
    @property
    def _llm_type(self) -> str:
        return "groq"
    
    def _call(
        self,
        prompt: str,
        stop: Optional[List[str]] = None,
        run_manager: Optional[CallbackManagerForLLMRun] = None,
        **kwargs: Any,
    ) -> str:
        try:
            # Cria uma nova inst√¢ncia do cliente a cada chamada para evitar cache corrompido
            client = Groq(api_key=self.api_key)
            response = client.chat.completions.create(
                model=self.model_name,
                messages=[{"role": "user", "content": prompt}],
                temperature=0.7,
                max_tokens=2048
            )
            return response.choices[0].message.content
        except Exception as e:
            return f"Erro na API: {str(e)}"

class LocalRedacaoRAG:
    """Sistema RAG que carrega √≠ndices FAISS remotos para Reda√ß√£o."""
    
    def __init__(self):
        self.vectorstore = None
        self.success_vectorstore = None
        self.retriever = None
        self.success_retriever = None
        self.memory = None
        self.rag_chain = None
        self.embeddings = None
        self.is_initialized = False
        self.redacao_folder_path = FAISS_INDEX_DIR
        self.success_folder_path = FAISS_SUCCESS_INDEX_DIR
        
        # O setup de embeddings foi movido para o m√©todo initialize()
        # para evitar carregamento pesado durante a importa√ß√£o.

    def _setup_embeddings(self, model_name: str):
        """Configura o modelo de embeddings do Hugging Face."""
        # Se os embeddings j√° estiverem carregados, n√£o faz nada
        if self.embeddings:
            return
        
        try:
            self.embeddings = HuggingFaceEmbeddings(
                model_name=model_name,
                model_kwargs={'device': 'cpu'},
                encode_kwargs={'normalize_embeddings': True}
            )
        except Exception as e:
            if 'st' in globals() and hasattr(st, 'error'):
                st.error(f"Falha ao carregar o modelo de embeddings: {e}")
            self.embeddings = None

    def _download_file(self, url: str, local_path: str):
        """Baixa um arquivo de uma URL para um caminho local."""
        try:
            with requests.get(url, stream=True) as r:
                r.raise_for_status()
                with open(local_path, 'wb') as f:
                    for chunk in r.iter_content(chunk_size=8192):
                        f.write(chunk)
            print(f"‚úÖ Arquivo baixado: {local_path}")
            return True
        except requests.exceptions.RequestException as e:
            st.error(f"Erro de rede ao baixar {url}: {e}")
            print(f"‚ùå Erro de rede ao baixar {url}: {e}")
            return False
        
    def _ensure_faiss_index_is_ready(self) -> bool:
        """
        Garante que os √≠ndices FAISS estejam dispon√≠veis, baixando-os se necess√°rio.
        """
        os.makedirs(FAISS_INDEX_DIR, exist_ok=True)
        os.makedirs(FAISS_SUCCESS_INDEX_DIR, exist_ok=True)
        
        # Arquivos principais de reda√ß√£o (nomes padr√£o do FAISS)
        index_file = os.path.join(FAISS_INDEX_DIR, "index.faiss")
        pkl_file = os.path.join(FAISS_INDEX_DIR, "index.pkl")
        
        # Arquivos de casos de sucesso (nomes padr√£o do FAISS)
        success_index_file = os.path.join(FAISS_SUCCESS_INDEX_DIR, "index.faiss")
        success_pkl_file = os.path.join(FAISS_SUCCESS_INDEX_DIR, "index.pkl")

        # Verifica se todos os arquivos j√° existem
        if (os.path.exists(index_file) and os.path.exists(pkl_file) and 
            os.path.exists(success_index_file) and os.path.exists(success_pkl_file)):
            print("‚úÖ √çndices FAISS de reda√ß√£o j√° existem localmente.")
            return True

        st.info("üì• Baixando √≠ndices de reda√ß√£o do Hugging Face...")
        print("üì• Baixando √≠ndices de reda√ß√£o do Hugging Face...")

        # URLs dos arquivos principais no Hugging Face
        faiss_url = "https://huggingface.co/Andre13Filho/rag_enem/resolve/main/index_redacao.faiss"
        pkl_url = "https://huggingface.co/Andre13Filho/rag_enem/resolve/main/index_redacao.pkl"
        
        # URLs dos arquivos de casos de sucesso
        success_faiss_url = "https://huggingface.co/Andre13Filho/rag_enem/resolve/main/index_success_red.faiss"
        success_pkl_url = "https://huggingface.co/Andre13Filho/rag_enem/resolve/main/index_success_red.pkl"

        # Baixa os arquivos principais com nomes padr√£o do FAISS
        faiss_success = self._download_file(faiss_url, index_file)
        pkl_success = self._download_file(pkl_url, pkl_file)
        
        # Baixa os arquivos de casos de sucesso com nomes padr√£o do FAISS
        success_faiss_success = self._download_file(success_faiss_url, success_index_file)
        success_pkl_success = self._download_file(success_pkl_url, success_pkl_file)

        if (faiss_success and pkl_success and success_faiss_success and success_pkl_success):
            st.success("‚úÖ √çndices de reda√ß√£o baixados com sucesso!")
            return True
        else:
            st.error("‚ùå Falha ao baixar os arquivos dos √≠ndices de reda√ß√£o.")
            # Limpa arquivos parciais em caso de falha
            for file_path in [index_file, pkl_file, success_index_file, success_pkl_file]:
                if os.path.exists(file_path): 
                    os.remove(file_path)
            return False
            
    def initialize(self, api_key: str) -> bool:
        """
        Inicializa o sistema: baixa os √≠ndices, carrega os vectorstores e cria a cadeia RAG.
        """
        if self.is_initialized:
            return True
            
        # 1. Garantir que os √≠ndices FAISS est√£o dispon√≠veis
        if not self._ensure_faiss_index_is_ready():
            return False
            
        # 2. Carregar os Vectorstores FAISS (e configurar embeddings aqui)
        try:
            st.info("üìö Carregando base de conhecimento de reda√ß√£o (FAISS)...")
            print("üìö Carregando base de conhecimento de reda√ß√£o (FAISS)...")
            
            # Passo 2.1: Configurar embeddings ANTES de carregar o FAISS
            self._setup_embeddings(model_name="sentence-transformers/distiluse-base-multilingual-cased-v1")
            if not self.embeddings:
                st.error("Embeddings n√£o foram inicializadas. Abortando.")
                return False

            # Carrega o vectorstore principal de reda√ß√£o
            self.vectorstore = FAISS.load_local(
                FAISS_INDEX_DIR, 
                self.embeddings,
                allow_dangerous_deserialization=True # Necess√°rio para pkl
            )
            
            # Carrega o vectorstore de casos de sucesso
            self.success_vectorstore = FAISS.load_local(
                FAISS_SUCCESS_INDEX_DIR,
                self.embeddings,
                allow_dangerous_deserialization=True
            )
            
            print(f"‚úÖ Vectorstore principal carregado: {self.vectorstore.index.ntotal} documentos")
            print(f"‚úÖ Vectorstore de sucesso carregado: {self.success_vectorstore.index.ntotal} documentos")
            
            # 3. Criar retriever e RAG chain
            self.retriever = self.vectorstore.as_retriever(search_kwargs={"k": 5})
            self.success_retriever = self.success_vectorstore.as_retriever(search_kwargs={"k": 3})
            
            # Criar LLM personalizado
            llm = GroqLLM(api_key=api_key)
            
            # Configurar mem√≥ria para conversas
            self.memory = ConversationBufferMemory(
                memory_key="chat_history",
                return_messages=True,
                output_key="answer"
            )
            
            # Template de prompt espec√≠fico para reda√ß√£o
            prompt_template = """Voc√™ √© a Professora Carla, especialista em reda√ß√£o do ENEM. Responda como uma professora para uma estudante de 17 anos chamada Sther.

CONTEXTO DO CONHECIMENTO (Material Pedag√≥gico):
{context}

CASOS DE SUCESSO (Reda√ß√µes Nota 1000):
{success_cases}

HIST√ìRICO DA CONVERSA:
{chat_history}

PERGUNTA DA STHER:
{question}

INSTRU√á√ïES PARA RESPOSTA:

1. **SEJA DID√ÅTICA E ENCORAJADORA:**
   - Use uma linguagem clara e acess√≠vel para uma estudante de 17 anos
   - Seja espec√≠fica e construtiva nos feedbacks
   - Sempre termine com palavras de encorajamento

2. **ESTRUTURA SUAS RESPOSTAS:**
   - Use emojis e formata√ß√£o markdown para clareza
   - Organize o conte√∫do em se√ß√µes l√≥gicas
   - Destaque pontos importantes com **negrito**

3. **FOQUE NO ENEM:**
   - Baseie suas orienta√ß√µes nos crit√©rios do ENEM
   - Use exemplos pr√°ticos e aplic√°veis
   - Conecte teoria com pr√°tica

4. **USE O MATERIAL DE APOIO:**
   - Referencie o contexto pedag√≥gico quando relevante
   - Compare com casos de sucesso quando apropriado
   - D√™ exemplos espec√≠ficos de como melhorar

5. **ESTILO DA PROFESSORA CARLA:**
   - Seja maternal mas profissional
   - Use analogias simples quando necess√°rio
   - Mantenha o foco na evolu√ß√£o da estudante

CONTEXTO ADICIONAL:
- Sther √© dedicada e quer muito bem no ENEM
- Ela se esfor√ßa muito em reda√ß√£o mas √†s vezes fica insegura
- Precisa de orienta√ß√£o espec√≠fica e pr√°tica

IMPORTANTE: 
- Se for an√°lise de reda√ß√£o, seja detalhada na corre√ß√£o
- Se for d√∫vida sobre t√©cnicas, seja espec√≠fica e pr√°tica
- Se for pedido de exemplos, use os casos de sucesso como refer√™ncia

RESPOSTA (com conceitos bem formatados e estilo da Professora Carla):"""

            # Criar cadeia RAG conversacional
            self.rag_chain = ConversationalRetrievalChain.from_llm(
                llm=llm,
                retriever=self.retriever,
                memory=self.memory,
                return_source_documents=True,
                verbose=False,
                combine_docs_chain_kwargs={"prompt_template": prompt_template}
            )
            
            st.success("‚úÖ Sistema RAG de reda√ß√£o inicializado com sucesso!")
            self.is_initialized = True
            return True
            
        except Exception as e:
            st.error(f"‚ùå Erro ao inicializar o sistema RAG: {str(e)}")
            print(f"‚ùå Erro ao inicializar o sistema RAG: {str(e)}")
            return False
    
    def get_response(self, question: str) -> Dict[str, Any]:
        """Obt√©m uma resposta do sistema RAG."""
        if not self.rag_chain:
            return {"answer": "O sistema RAG n√£o foi inicializado corretamente."}
        
        try:
            # Verificar se a pergunta parece ser uma reda√ß√£o para an√°lise
            if self._is_redacao_for_analysis(question):
                # Obter API key
                api_key = None
                if hasattr(st, 'secrets') and "GROQ_API_KEY" in st.secrets:
                    api_key = st.secrets["GROQ_API_KEY"]
                else:
                    api_key = os.environ.get("GROQ_API_KEY")
                
                if api_key:
                    # Analisar como reda√ß√£o
                    analysis = self.analyze_redacao_text(question, "Reda√ß√£o via Chat", api_key)
                    return {"answer": analysis}
            
            return self.rag_chain({"question": question})
        except Exception as e:
            return {"answer": f"Erro ao processar a pergunta: {str(e)}"}
    
    def _is_redacao_for_analysis(self, text: str) -> bool:
        """Detecta se o texto parece ser uma reda√ß√£o para an√°lise"""
        # Crit√©rios para detectar reda√ß√£o
        words = text.split()
        word_count = len(words)
        
        # Deve ter pelo menos 100 palavras
        if word_count < 100:
            return False
            
        # Procurar por indicadores de reda√ß√£o
        redacao_indicators = [
            "professora carla",
            "poderia analisar",
            "minha reda√ß√£o",
            "reda√ß√£o:",
            "an√°lise da reda√ß√£o",
            "corrija minha reda√ß√£o",
            "avalie minha reda√ß√£o"
        ]
        
        text_lower = text.lower()
        for indicator in redacao_indicators:
            if indicator in text_lower:
                return True
        
        # Verificar estrutura de reda√ß√£o (par√°grafos)
        paragraphs = [p.strip() for p in text.split('\n\n') if p.strip()]
        if len(paragraphs) >= 3 and word_count > 150:
            # Verificar se tem caracter√≠sticas de disserta√ß√£o
            intro_words = ["atualmente", "nos dias de hoje", "na sociedade", "√© ineg√°vel", "√© not√≥rio"]
            concl_words = ["portanto", "dessa forma", "assim", "diante disso", "logo"]
            
            has_intro = any(word in text_lower for word in intro_words)
            has_concl = any(word in text_lower for word in concl_words)
            
            if has_intro or has_concl:
                return True
        
        return False
    
    def search_relevant_content(self, query: str, k: int = 3) -> List[Document]:
        """Busca por conte√∫do relevante no vectorstore principal."""
        if not self.vectorstore:
            return []
        
        try:
            return self.vectorstore.similarity_search(query, k=k)
        except Exception as e:
            print(f"Erro na busca de similaridade: {str(e)}")
            return []
    
    def search_success_cases(self, query: str, k: int = 2) -> List[Document]:
        """Busca por casos de sucesso relevantes."""
        if not self.success_vectorstore:
            return []
        
        try:
            return self.success_vectorstore.similarity_search(query, k=k)
        except Exception as e:
            print(f"Erro na busca de casos de sucesso: {str(e)}")
            return []
    
    def get_stats(self) -> Dict[str, Any]:
        """
        Retorna estat√≠sticas detalhadas do sistema RAG, incluindo uma amostra de documentos.
        """
        if not self.is_initialized or not self.vectorstore:
            return {
                "status": "N√£o Carregado",
                "total_documents": 0,
                "success_cases": 0,
                "sample_documents": []
            }

        try:
            total_documents = self.vectorstore.index.ntotal
            success_cases = self.success_vectorstore.index.ntotal if self.success_vectorstore else 0
            
            # Pega uma amostra de metadados dos primeiros 5 documentos
            sample_docs_metadata = []
            docstore = self.vectorstore.docstore
            doc_ids = list(docstore._dict.keys())
            
            for i in range(min(5, len(doc_ids))):
                doc = docstore._dict[doc_ids[i]]
                if doc.metadata:
                    sample_docs_metadata.append(doc.metadata)

            # Extrai nomes de arquivos √∫nicos da amostra
            sample_files = sorted(list(set(
                meta.get("source", "Fonte Desconhecida") for meta in sample_docs_metadata
            )))

            return {
                "status": "Carregado",
                "total_documents": total_documents,
                "success_cases": success_cases,
                "sample_documents": sample_files
            }
        except Exception as e:
            print(f"Erro ao obter estat√≠sticas do RAG: {e}")
            return {
                "status": "Erro na Leitura",
                "total_documents": 0,
                "success_cases": 0,
                "sample_documents": [str(e)]
            }
    
    def clear_memory(self):
        """Limpa a mem√≥ria da conversa."""
        if self.memory:
            self.memory.clear()

    def extract_text_from_pdf(self, pdf_content: bytes) -> str:
        """Extrai texto do PDF usando m√∫ltiplas estrat√©gias"""
        text = ""
        
        if not PDF_AVAILABLE:
            return "Bibliotecas de PDF n√£o est√£o instaladas. Instale: pip install PyPDF2 PyMuPDF"
        
        # Estrat√©gia 1: PyPDF2 para PDFs com texto
        try:
            with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp_file:
                tmp_file.write(pdf_content)
                tmp_file.flush()
                
                with open(tmp_file.name, 'rb') as file:
                    pdf_reader = PyPDF2.PdfReader(file)
                    for page in pdf_reader.pages:
                        page_text = page.extract_text()
                        if page_text.strip():
                            text += page_text + "\n"
                
                os.unlink(tmp_file.name)
                
                if text.strip():
                    return text
        except Exception as e:
            print(f"Erro PyPDF2: {e}")

        # Estrat√©gia 2: PyMuPDF para PDFs mais complexos  
        try:
            pdf_document = fitz.open(stream=pdf_content, filetype="pdf")
            for page_num in range(pdf_document.page_count):
                page = pdf_document[page_num]
                page_text = page.get_text()
                if page_text.strip():
                    text += page_text + "\n"
            pdf_document.close()
            
            if text.strip():
                return text
        except Exception as e:
            print(f"Erro PyMuPDF: {e}")

        return text if text.strip() else "N√£o foi poss√≠vel extrair texto do PDF."

    def analyze_redacao_text(self, texto_redacao: str, filename: str, api_key: str) -> str:
        """Analisa o texto da reda√ß√£o usando RAG e retorna feedback detalhado"""
        
        # Garantir que o sistema est√° inicializado
        if not self.is_initialized:
            if not self.initialize(api_key):
                return "‚ùå Erro ao inicializar sistema de an√°lise. Verifique sua conex√£o com a internet."
        
        # An√°lises b√°sicas da reda√ß√£o
        palavras = len(texto_redacao.split())
        paragrafos = len([p for p in texto_redacao.split('\n\n') if p.strip()])
        linhas = len([l for l in texto_redacao.split('\n') if l.strip()])
        
        # Buscar material relevante sobre reda√ß√£o
        query_redacao = f"crit√©rios avalia√ß√£o ENEM reda√ß√£o compet√™ncias estrutura argumenta√ß√£o"
        redacao_docs = self.search_relevant_content(query_redacao, k=5)
        
        # Buscar casos de sucesso para compara√ß√£o
        query_sucesso = f"reda√ß√£o nota 1000 exemplos"
        success_docs = self.search_success_cases(query_sucesso, k=3)
        
        # Montar contexto para an√°lise
        context_redacao = "\n\n".join([doc.page_content for doc in redacao_docs])
        context_success = "\n\n".join([doc.page_content for doc in success_docs])
        
        # Prompt espec√≠fico para an√°lise de reda√ß√£o
        analysis_prompt = f"""
**AN√ÅLISE DETALHADA DA REDA√á√ÉO DA STHER**

**ARQUIVO:** {filename}
**TEXTO DA REDA√á√ÉO:**
{texto_redacao}

**ESTAT√çSTICAS:**
- Palavras: {palavras}
- Par√°grafos: {paragrafos}  
- Linhas: {linhas}

**TAREFA:** Analise esta reda√ß√£o seguindo rigorosamente os crit√©rios do ENEM e forne√ßa:

1. **NOTA FINAL (0-1000):** Baseada nas 5 compet√™ncias do ENEM
2. **AN√ÅLISE POR COMPET√äNCIA:** Com nota individual e feedback espec√≠fico
3. **PONTOS FORTES:** O que Sther fez bem
4. **PONTOS A MELHORAR:** Espec√≠ficos e acion√°veis  
5. **PLANO DE MELHORIA:** Passos concretos para chegar √† nota 1000
6. **COMPARA√á√ÉO COM NOTA 1000:** Como esta reda√ß√£o se compara aos exemplos de sucesso

**COMPET√äNCIAS DO ENEM:**
- C1: Demonstrar dom√≠nio da modalidade escrita formal da L√≠ngua Portuguesa
- C2: Compreender a proposta de reda√ß√£o e aplicar conceitos das v√°rias √°reas de conhecimento
- C3: Selecionar, relacionar, organizar e interpretar informa√ß√µes, fatos, opini√µes e argumentos em defesa de um ponto de vista
- C4: Demonstrar conhecimento dos mecanismos lingu√≠sticos necess√°rios para a constru√ß√£o da argumenta√ß√£o
- C5: Elaborar proposta de interven√ß√£o para o problema abordado, respeitando os direitos humanos

**SEJA ESPEC√çFICA, CONSTRUTIVA E MOTIVACIONAL COMO A PROFESSORA CARLA QUE √â!**
"""

        try:
            # Usar o RAG para gerar an√°lise especializada
            response = self.rag_chain({
                "question": analysis_prompt,
                "context": context_redacao,
                "success_cases": context_success
            })
            
            analysis = response.get("answer", "Erro na an√°lise")
            
            # Adicionar cabe√ßalho formatado
            final_analysis = f"""
# üìù **CORRE√á√ÉO COMPLETA DA REDA√á√ÉO**

**üìÇ Arquivo:** {filename}  
**üìÖ Data:** {datetime.now().strftime("%d/%m/%Y √†s %H:%M")}  
**üë©‚Äçüè´ Professora:** Carla  

---

{analysis}

---

## üéØ **PR√ìXIMOS PASSOS**

### üìö **Para sua pr√≥xima reda√ß√£o:**
1. **Revise** os pontos destacados acima
2. **Pratique** as compet√™ncias que precisam de melhoria  
3. **Leia** reda√ß√µes nota 1000 para se inspirar
4. **Escreva** aplicando as corre√ß√µes sugeridas

### üí™ **Mensagem da Professora Carla:**
> "Sther, cada reda√ß√£o √© um passo importante na sua jornada rumo ao ENEM! Continue praticando com dedica√ß√£o. Voc√™ tem potencial para alcan√ßar a nota 1000! üåü"

**‚ú® A nota 1000 est√° ao seu alcance! Continue se esfor√ßando! ‚ú®**
"""
            
            return final_analysis
            
        except Exception as e:
            return f"""
# ‚ùå **Erro na An√°lise**

Desculpe, Sther! Houve um problema t√©cnico na an√°lise da sua reda√ß√£o.

**Erro:** {str(e)}

## üìû **O que fazer:**
1. Verifique sua conex√£o com a internet
2. Tente novamente em alguns minutos
3. Se o problema persistir, fale com o suporte t√©cnico

**Mesmo assim, aqui est√£o algumas dicas gerais para voc√™:**

### üéØ **Crit√©rios b√°sicos do ENEM:**
- **Estrutura:** Introdu√ß√£o, desenvolvimento (2-3 par√°grafos), conclus√£o
- **Argumenta√ß√£o:** Use dados, exemplos e repert√≥rio sociocultural
- **Coes√£o:** Conecte ideias com conectivos adequados
- **Linguagem:** Mantenha registro formal
- **Proposta:** Detalhe quem, o que, como e para qu√™

**Continue praticando! A Professora Carla acredita em voc√™! üí™**
"""

_singleton_instance = None

def get_local_redacao_rag_instance():
    """
    Retorna uma inst√¢ncia √∫nica (singleton) do LocalRedacaoRAG.
    Isso evita a inicializa√ß√£o no momento da importa√ß√£o.
    """
    global _singleton_instance
    if _singleton_instance is None:
        _singleton_instance = LocalRedacaoRAG()
    return _singleton_instance

def analyze_redacao_pdf(pdf_content: bytes, filename: str) -> str:
    """Fun√ß√£o principal para an√°lise completa de reda√ß√£o em PDF"""
    
    # Obter inst√¢ncia do RAG
    rag_instance = get_local_redacao_rag_instance()
    
    # Obter API key
    api_key = None
    if hasattr(st, 'secrets') and "GROQ_API_KEY" in st.secrets:
        api_key = st.secrets["GROQ_API_KEY"]
    else:
        api_key = os.environ.get("GROQ_API_KEY")
    
    if not api_key:
        return """
# üîë **Configura√ß√£o Necess√°ria**

Ol√°, Sther! Para analisar sua reda√ß√£o, preciso que a chave da API Groq seja configurada.

**Como configurar:**
1. Acesse [Groq Console](https://console.groq.com/)
2. Gere sua API key gratuita
3. Configure nos Secrets do Streamlit ou vari√°veis de ambiente

**Enquanto isso, aqui est√£o algumas dicas:**
- Mantenha estrutura de 4-5 par√°grafos
- Use repert√≥rio sociocultural relevante
- Detalhe bem sua proposta de interven√ß√£o
- Revise gram√°tica e coes√£o

**A Professora Carla est√° ansiosa para te ajudar! üåü**
"""
    
    try:
        # Extrair texto do PDF
        texto_redacao = rag_instance.extract_text_from_pdf(pdf_content)
        
        if not texto_redacao or texto_redacao.startswith("N√£o foi poss√≠vel") or texto_redacao.startswith("Bibliotecas"):
            return f"""
# ‚ùå **Problema com o PDF**

**Arquivo:** {filename}

N√£o consegui extrair o texto do seu PDF. Isso pode acontecer por alguns motivos:

## üîß **Poss√≠veis solu√ß√µes:**
1. **PDF de imagem:** Se sua reda√ß√£o foi escaneada, o PDF cont√©m apenas imagens
2. **PDF protegido:** Alguns PDFs t√™m prote√ß√£o que impede extra√ß√£o de texto
3. **Formato incompat√≠vel:** Tente salvar novamente como PDF

## üí° **Como resolver:**
- **Recomendado:** Digite sua reda√ß√£o diretamente no chat para an√°lise
- **Alternativa:** Use um conversor online para transformar imagem em texto
- **OCR:** Use Google Lens ou similar para extrair texto de imagens

## üìù **Envie por texto:**
Voc√™ pode copiar e colar sua reda√ß√£o diretamente no chat com a mensagem:
> "Professora Carla, poderia analisar minha reda√ß√£o: [COLE SEU TEXTO AQUI]"

**A Professora Carla est√° pronta para te ajudar de qualquer forma! üí™**
"""
        
        # Verificar se o texto extra√≠do √© v√°lido
        if len(texto_redacao.split()) < 50:
            return f"""
# ‚ö†Ô∏è **Texto muito curto**

**Arquivo:** {filename}  
**Palavras extra√≠das:** {len(texto_redacao.split())}

O texto extra√≠do parece muito curto para uma reda√ß√£o ENEM (m√≠nimo ~150 palavras).

**Texto extra√≠do:**
```
{texto_redacao[:500]}...
```

## üí° **Sugest√µes:**
1. Verifique se o PDF cont√©m o texto completo da reda√ß√£o
2. Tente enviar sua reda√ß√£o por texto diretamente no chat
3. Certifique-se de que a reda√ß√£o tem pelo menos 150 palavras

**A Professora Carla aguarda sua reda√ß√£o completa para uma an√°lise detalhada! üìù**
"""
        
        # Realizar an√°lise completa
        return rag_instance.analyze_redacao_text(texto_redacao, filename, api_key)
        
    except Exception as e:
        return f"""
# ‚ùå **Erro T√©cnico**

**Arquivo:** {filename}  
**Erro:** {str(e)}

Desculpe, Sther! Houve um problema t√©cnico ao processar sua reda√ß√£o.

## üîÑ **Tente:**
1. Enviar o arquivo novamente
2. Verificar se o PDF n√£o est√° corrompido
3. Enviar a reda√ß√£o por texto no chat

## üì± **Contato:**
Se o problema persistir, relate este erro para o suporte t√©cnico.

**A Professora Carla est√° aqui para te ajudar! N√£o desista! üí™**
"""

def setup_redacao_ui():
    """Configura a interface do sistema de reda√ß√£o"""
    st.markdown("""
    <div class="teacher-intro">
        <h3>‚úçÔ∏è Professora Carla - An√°lise de Reda√ß√£o</h3>
        <p>Sistema completo de an√°lise baseado nos crit√©rios do ENEM</p>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown("### üì§ **Envie sua Reda√ß√£o**")
    
    uploaded_file = st.file_uploader(
        "Escolha um arquivo PDF com sua reda√ß√£o:",
        type=['pdf'],
        help="Envie sua reda√ß√£o em formato PDF para an√°lise completa"
    )
    
    if uploaded_file is not None:
        if st.button("üîç Analisar Reda√ß√£o", type="primary"):
            with st.spinner("üìù Professora Carla analisando sua reda√ß√£o..."):
                try:
                    # L√™ o conte√∫do do arquivo
                    pdf_content = uploaded_file.read()
                    
                    # Analisa a reda√ß√£o
                    analise = analyze_redacao_pdf(pdf_content, uploaded_file.name)
                    
                    # Exibe o resultado
                    st.markdown("### üìã **Resultado da An√°lise**")
                    st.markdown(analise)
                    
                    # Bot√£o para download do relat√≥rio
                    st.download_button(
                        label="üì• Baixar Relat√≥rio Completo",
                        data=analise,
                        file_name=f"analise_redacao_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md",
                        mime="text/markdown"
                    )
                    
                except Exception as e:
                    st.error(f"‚ùå Erro ao processar a reda√ß√£o: {str(e)}")
                    st.info("üí° Verifique se o arquivo √© um PDF v√°lido e tente novamente.")
    
    # Informa√ß√µes adicionais
    with st.expander("‚ÑπÔ∏è Como funciona a an√°lise?"):
        st.markdown("""
        **A Professora Carla analisa sua reda√ß√£o baseada nos 5 crit√©rios do ENEM:**
        
        1. **üèóÔ∏è Estrutura Textual** - Organiza√ß√£o e formato dissertativo-argumentativo
        2. **üí≠ Conte√∫do** - Argumenta√ß√£o e repert√≥rio sociocultural  
        3. **üó£Ô∏è Linguagem** - Coes√£o, registro formal e variedade lexical
        4. **üéØ Argumenta√ß√£o** - Desenvolvimento l√≥gico das ideias
        5. **üìã Proposta de Interven√ß√£o** - Detalhamento e viabilidade
        
        **üìä Voc√™ receber√°:**
        - Nota de 0 a 1000 pontos
        - Feedback detalhado por compet√™ncia
        - Sugest√µes espec√≠ficas de melhoria
        - Dicas personalizadas da Professora Carla
        """)
    
    # Casos de sucesso
    with st.expander("üèÜ Exemplos de Reda√ß√µes Nota 1000"):
        st.markdown("**Inspire-se com estes exemplos:**")
        st.markdown("- üìù Reda√ß√£o sobre tecnologia e sociedade")
        st.markdown("- üìù Reda√ß√£o sobre meio ambiente")
        st.markdown("- üìù Reda√ß√£o sobre educa√ß√£o") 