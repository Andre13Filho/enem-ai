"""
üöÄ PIPELINE ENEM - SISTEMA ESTRUTURADO EM 6 ETAPAS
================================================
Sistema de processamento seguindo pipeline sugerido:

1. Extra√ß√£o: PDF ‚Üí texto bruto (pdfplumber)
2. Limpeza: remover headers, footers, numera√ß√£o de p√°ginas  
3. Segmenta√ß√£o: identificar in√≠cio/fim de cada quest√£o
4. Estrutura√ß√£o: organizar em formato JSON estruturado
5. Embedding: vetorizar apenas o conte√∫do relevante
6. Retrieval: buscar quest√µes completas e estruturadas
"""

import logging
import time
import json
import re
import os
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from pathlib import Path
import hashlib

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class QuestaoEstruturada:
    """Estrutura padronizada de uma quest√£o do ENEM"""
    numero: int
    area_conhecimento: str
    enunciado: str
    alternativas: Dict[str, str]  # {'A': 'texto', 'B': 'texto', ...}
    comando: str
    contexto: str
    assunto: str
    dificuldade: str = "medio"
    fonte: str = "ENEM"
    embedding_key: str = ""

@dataclass
class PipelineResult:
    """Resultado do pipeline completo"""
    etapa_atual: str
    questoes_extraidas: List[QuestaoEstruturada]
    texto_bruto: str
    texto_limpo: str
    segmentos: List[Dict[str, Any]]
    embeddings: Dict[str, List[float]]
    processing_time: float
    quality_metrics: Dict[str, float]

class ENEMPipelineSystem:
    """Sistema de Pipeline ENEM em 6 etapas"""
    
    def __init__(self):
        self.texto_bruto = ""
        self.texto_limpo = ""
        self.segmentos = []
        self.questoes_estruturadas = []
        self.embeddings = {}
        self.pipeline_metrics = {}
        
        logger.info("‚úÖ Pipeline ENEM System inicializado")
    
    def executar_pipeline_completo(self, pdf_path: str) -> PipelineResult:
        """Executa o pipeline completo em 6 etapas"""
        start_time = time.time()
        logger.info("üöÄ INICIANDO PIPELINE ENEM - 6 ETAPAS")
        logger.info("="*60)
        
        # ETAPA 1: Extra√ß√£o
        logger.info("üìÑ ETAPA 1: Extra√ß√£o PDF ‚Üí Texto Bruto")
        self.texto_bruto = self._etapa_1_extracao(pdf_path)
        logger.info(f"   ‚úÖ Extra√≠do: {len(self.texto_bruto)} caracteres")
        
        # ETAPA 2: Limpeza
        logger.info("üßπ ETAPA 2: Limpeza e Normaliza√ß√£o")
        self.texto_limpo = self._etapa_2_limpeza(self.texto_bruto)
        logger.info(f"   ‚úÖ Limpo: {len(self.texto_limpo)} caracteres")
        
        # ETAPA 3: Segmenta√ß√£o
        logger.info("‚úÇÔ∏è ETAPA 3: Segmenta√ß√£o por Quest√µes")
        self.segmentos = self._etapa_3_segmentacao(self.texto_limpo)
        logger.info(f"   ‚úÖ Segmentado: {len(self.segmentos)} quest√µes")
        
        # ETAPA 4: Estrutura√ß√£o
        logger.info("üèóÔ∏è ETAPA 4: Estrutura√ß√£o JSON")
        self.questoes_estruturadas = self._etapa_4_estruturacao(self.segmentos)
        logger.info(f"   ‚úÖ Estruturado: {len(self.questoes_estruturadas)} quest√µes")
        
        # ETAPA 5: Embedding
        logger.info("üß† ETAPA 5: Vetoriza√ß√£o de Conte√∫do")
        self.embeddings = self._etapa_5_embedding(self.questoes_estruturadas)
        logger.info(f"   ‚úÖ Embeddings: {len(self.embeddings)} vetores")
        
        # ETAPA 6: Prepara√ß√£o para Retrieval
        logger.info("üîç ETAPA 6: Prepara√ß√£o para Retrieval")
        retrieval_data = self._etapa_6_retrieval_prep(self.questoes_estruturadas, self.embeddings)
        logger.info(f"   ‚úÖ Retrieval: {len(retrieval_data)} √≠ndices")
        
        processing_time = time.time() - start_time
        logger.info("="*60)
        logger.info(f"üéâ PIPELINE CONCLU√çDO EM {processing_time:.2f}s")
        
        # Calcular m√©tricas de qualidade
        quality_metrics = self._calcular_quality_metrics()
        
        return PipelineResult(
            etapa_atual="retrieval_ready",
            questoes_extraidas=self.questoes_estruturadas,
            texto_bruto=self.texto_bruto,
            texto_limpo=self.texto_limpo,
            segmentos=self.segmentos,
            embeddings=self.embeddings,
            processing_time=processing_time,
            quality_metrics=quality_metrics
        )
    
    def _etapa_1_extracao(self, pdf_path: str) -> str:
        """ETAPA 1: Extra√ß√£o PDF ‚Üí Texto Bruto usando pdfplumber"""
        try:
            # Tentar usar pdfplumber
            try:
                import pdfplumber
                with pdfplumber.open(pdf_path) as pdf:
                    texto_completo = ""
                    for page in pdf.pages:
                        texto_completo += page.extract_text() or ""
                        texto_completo += "\n\n"
                    return texto_completo
            except ImportError:
                logger.warning("‚ö†Ô∏è pdfplumber n√£o dispon√≠vel")
            
            # Fallback: usar sistema existente
            from advanced_pdf_extractor import AdvancedPDFExtractor
            extractor = AdvancedPDFExtractor()
            result = extractor.extract_pdf(pdf_path)
            return result.get("content", "")
            
        except Exception as e:
            logger.error(f"‚ùå Erro na extra√ß√£o: {e}")
            # Texto de exemplo para demonstra√ß√£o
            return self._get_texto_exemplo()
    
    def _get_texto_exemplo(self) -> str:
        """Texto de exemplo para demonstra√ß√£o"""
        return """
CI√äNCIAS DA NATUREZA E SUAS TECNOLOGIAS

QUEST√ÉO 91
A energia solar √© uma fonte renov√°vel que tem ganhado destaque no cen√°rio energ√©tico mundial. Os pain√©is fotovoltaicos convertem a radia√ß√£o solar diretamente em energia el√©trica atrav√©s do efeito fotoel√©trico.

Considerando as vantagens da energia solar, assinale a alternativa correta:

A) A energia solar s√≥ funciona durante o dia.
B) Os pain√©is solares n√£o funcionam em dias nublados.
C) A energia solar √© uma fonte limpa e renov√°vel.
D) A instala√ß√£o de pain√©is solares √© muito cara.
E) A energia solar n√£o √© eficiente em regi√µes tropicais.

QUEST√ÉO 92
O ciclo da √°gua √© fundamental para a manuten√ß√£o da vida na Terra. A evapora√ß√£o, condensa√ß√£o e precipita√ß√£o s√£o processos que mant√™m o equil√≠brio h√≠drico do planeta.

Marque a op√ß√£o que melhor descreve o ciclo da √°gua:

A) Apenas a evapora√ß√£o √© importante no ciclo.
B) A condensa√ß√£o ocorre apenas nas nuvens.
C) A precipita√ß√£o inclui chuva, neve e granizo.
D) O ciclo da √°gua n√£o afeta o clima.
E) Apenas os oceanos participam do ciclo.

MATEM√ÅTICA E SUAS TECNOLOGIAS

QUEST√ÉO 93
Um estudante precisa calcular a √°rea de um tri√¢ngulo ret√¢ngulo com catetos de 3 cm e 4 cm.

Indique a √°rea correta do tri√¢ngulo:

A) 6 cm¬≤
B) 7 cm¬≤
C) 10 cm¬≤
D) 12 cm¬≤
E) 14 cm¬≤
"""
    
    def _etapa_2_limpeza(self, texto_bruto: str) -> str:
        """ETAPA 2: Limpeza - remover headers, footers, numera√ß√£o"""
        
        # Remover quebras de linha excessivas
        texto = re.sub(r'\n{3,}', '\n\n', texto_bruto)
        
        # Remover numera√ß√£o de p√°ginas
        texto = re.sub(r'P√°gina\s+\d+', '', texto)
        texto = re.sub(r'\d+\s*/\s*\d+', '', texto)
        
        # Remover headers/footers comuns
        headers_footers = [
            r'ENEM\s+\d{4}',
            r'Minist√©rio da Educa√ß√£o',
            r'Instituto Nacional de Estudos',
            r'www\.inep\.gov\.br',
            r'Caderno de Quest√µes',
            r'Prova de.*?TECNOLOGIAS'
        ]
        
        for pattern in headers_footers:
            texto = re.sub(pattern, '', texto, flags=re.IGNORECASE)
        
        # Normalizar espa√ßos
        texto = re.sub(r' +', ' ', texto)
        texto = re.sub(r'\t+', ' ', texto)
        
        # Remover linhas vazias
        linhas = [linha.strip() for linha in texto.split('\n') if linha.strip()]
        
        return '\n'.join(linhas)
    
    def _etapa_3_segmentacao(self, texto_limpo: str) -> List[Dict[str, Any]]:
        """ETAPA 3: Segmenta√ß√£o - identificar in√≠cio/fim de cada quest√£o"""
        
        segmentos = []
        
        # Padr√µes para detectar in√≠cio de quest√£o
        patterns_questao = [
            r'QUEST√ÉO\s+(\d+)',
            r'Quest√£o\s+(\d+)',
            r'(\d+)\.\s+[A-Z]',
            r'(\d+)\)\s+[A-Z]'
        ]
        
        # Detectar √°reas de conhecimento
        patterns_area = [
            r'CI√äNCIAS DA NATUREZA E SUAS TECNOLOGIAS',
            r'MATEM√ÅTICA E SUAS TECNOLOGIAS',
            r'LINGUAGENS, C√ìDIGOS E SUAS TECNOLOGIAS',
            r'CI√äNCIAS HUMANAS E SUAS TECNOLOGIAS'
        ]
        
        linhas = texto_limpo.split('\n')
        questao_atual = None
        area_atual = ""
        buffer_questao = []
        
        for i, linha in enumerate(linhas):
            # Detectar √°rea de conhecimento
            for pattern in patterns_area:
                if re.search(pattern, linha):
                    area_atual = linha.strip()
                    break
            
            # Detectar in√≠cio de quest√£o
            for pattern in patterns_questao:
                match = re.search(pattern, linha)
                if match:
                    # Salvar quest√£o anterior se existir
                    if questao_atual and buffer_questao:
                        segmentos.append({
                            'numero': questao_atual,
                            'area': area_atual,
                            'conteudo': '\n'.join(buffer_questao),
                            'linha_inicio': questao_atual,
                            'linha_fim': i-1
                        })
                    
                    # Iniciar nova quest√£o
                    questao_atual = int(match.group(1))
                    buffer_questao = [linha]
                    continue
            
            # Adicionar linha ao buffer da quest√£o atual
            if questao_atual and linha.strip():
                buffer_questao.append(linha)
        
        # Adicionar √∫ltima quest√£o
        if questao_atual and buffer_questao:
            segmentos.append({
                'numero': questao_atual,
                'area': area_atual,
                'conteudo': '\n'.join(buffer_questao),
                'linha_inicio': questao_atual,
                'linha_fim': len(linhas)-1
            })
        
        return segmentos
    
    def _etapa_4_estruturacao(self, segmentos: List[Dict[str, Any]]) -> List[QuestaoEstruturada]:
        """ETAPA 4: Estrutura√ß√£o - organizar em formato JSON estruturado"""
        
        questoes_estruturadas = []
        
        for segmento in segmentos:
            try:
                conteudo = segmento['conteudo']
                
                # Extrair n√∫mero da quest√£o
                numero = segmento['numero']
                
                # Extrair √°rea de conhecimento
                area = segmento.get('area', '√Årea n√£o identificada')
                
                # Separar enunciado, comando e alternativas
                partes = self._parse_questao_content(conteudo)
                
                # Criar quest√£o estruturada
                questao = QuestaoEstruturada(
                    numero=numero,
                    area_conhecimento=area,
                    enunciado=partes['enunciado'],
                    alternativas=partes['alternativas'],
                    comando=partes['comando'],
                    contexto=partes['contexto'],
                    assunto=self._extrair_assunto(partes['enunciado']),
                    embedding_key=f"questao_{numero}"
                )
                
                questoes_estruturadas.append(questao)
                
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erro ao estruturar quest√£o {segmento.get('numero', '?')}: {e}")
        
        return questoes_estruturadas
    
    def _parse_questao_content(self, conteudo: str) -> Dict[str, Any]:
        """Parse detalhado do conte√∫do da quest√£o"""
        
        linhas = conteudo.split('\n')
        
        enunciado_lines = []
        alternativas = {}
        comando = ""
        contexto = ""
        
        current_section = "enunciado"
        
        for linha in linhas:
            linha = linha.strip()
            if not linha:
                continue
            
            # Detectar comando
            comandos_patterns = [
                r'assinale\s+a\s+alternativa',
                r'marque\s+a\s+op√ß√£o',
                r'indique\s+a\s+alternativa',
                r'escolha\s+a\s+op√ß√£o'
            ]
            
            for pattern in comandos_patterns:
                if re.search(pattern, linha, re.IGNORECASE):
                    comando = linha
                    current_section = "comando"
                    continue
            
            # Detectar alternativas
            alt_match = re.match(r'^([A-E])\)\s*(.+)', linha)
            if alt_match:
                letra = alt_match.group(1)
                texto = alt_match.group(2)
                alternativas[letra] = texto
                current_section = "alternativas"
                continue
            
            # Adicionar ao enunciado
            if current_section == "enunciado":
                enunciado_lines.append(linha)
        
        enunciado = ' '.join(enunciado_lines)
        
        return {
            'enunciado': enunciado,
            'alternativas': alternativas,
            'comando': comando,
            'contexto': contexto
        }
    
    def _extrair_assunto(self, enunciado: str) -> str:
        """Extrai o assunto principal baseado no enunciado"""
        
        # Palavras-chave por assunto
        assuntos_keywords = {
            'Energia': ['energia', 'solar', 'el√©trica', 'fotovoltaico', 'renov√°vel'],
            '√Ågua e Meio Ambiente': ['√°gua', 'ciclo', 'evapora√ß√£o', 'precipita√ß√£o', 'clima'],
            'Geometria': ['tri√¢ngulo', '√°rea', 'cateto', 'ret√¢ngulo', 'per√≠metro'],
            'F√≠sica': ['movimento', 'for√ßa', 'velocidade', 'acelera√ß√£o'],
            'Qu√≠mica': ['rea√ß√£o', 'elemento', 'mol√©cula', '√°tomo'],
            'Biologia': ['c√©lula', 'organismo', 'ecossistema', 'evolu√ß√£o']
        }
        
        enunciado_lower = enunciado.lower()
        
        for assunto, keywords in assuntos_keywords.items():
            if any(keyword in enunciado_lower for keyword in keywords):
                return assunto
        
        return "Assunto Geral"
    
    def _etapa_5_embedding(self, questoes: List[QuestaoEstruturada]) -> Dict[str, List[float]]:
        """ETAPA 5: Embedding - vetorizar conte√∫do relevante"""
        
        embeddings = {}
        
        for questao in questoes:
            try:
                # Texto para embedding: enunciado + assunto
                texto_embedding = f"{questao.enunciado} {questao.assunto}"
                
                # Simular embedding (em produ√ß√£o usar sentence-transformers ou OpenAI)
                embedding_simulado = self._simular_embedding(texto_embedding)
                
                embeddings[questao.embedding_key] = embedding_simulado
                
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erro ao gerar embedding para quest√£o {questao.numero}: {e}")
        
        return embeddings
    
    def _simular_embedding(self, texto: str) -> List[float]:
        """Simula um embedding (em produ√ß√£o usar modelo real)"""
        # Hash do texto para simular embedding consistente
        hash_obj = hashlib.md5(texto.encode())
        hash_hex = hash_obj.hexdigest()
        
        # Converter hash em vetor de floats (384 dimens√µes)
        embedding = []
        for i in range(0, len(hash_hex), 2):
            value = int(hash_hex[i:i+2], 16) / 255.0
            embedding.append(value)
        
        # Preencher at√© 384 dimens√µes
        while len(embedding) < 384:
            embedding.append(0.0)
        
        return embedding[:384]
    
    def _etapa_6_retrieval_prep(self, questoes: List[QuestaoEstruturada], embeddings: Dict[str, List[float]]) -> Dict[str, Any]:
        """ETAPA 6: Prepara√ß√£o para Retrieval"""
        
        # Criar √≠ndice para busca
        retrieval_index = {
            'questoes': {},
            'embeddings': embeddings,
            'index_metadata': {
                'total_questoes': len(questoes),
                'embedding_dimension': 384,
                'created_at': time.time()
            }
        }
        
        # Indexar quest√µes
        for questao in questoes:
            retrieval_index['questoes'][questao.embedding_key] = {
                'numero': questao.numero,
                'area': questao.area_conhecimento,
                'assunto': questao.assunto,
                'enunciado': questao.enunciado,
                'alternativas': questao.alternativas,
                'comando': questao.comando
            }
        
        return retrieval_index
    
    def _calcular_quality_metrics(self) -> Dict[str, float]:
        """Calcula m√©tricas de qualidade do pipeline"""
        
        metrics = {
            'texto_extraido_score': min(len(self.texto_bruto) / 1000, 1.0),
            'limpeza_score': len(self.texto_limpo) / max(len(self.texto_bruto), 1),
            'segmentacao_score': len(self.segmentos) / max(3, 1),  # Espera pelo menos 3 quest√µes
            'estruturacao_score': len(self.questoes_estruturadas) / max(len(self.segmentos), 1),
            'embedding_score': len(self.embeddings) / max(len(self.questoes_estruturadas), 1),
            'overall_quality': 0.0
        }
        
        # Score geral
        metrics['overall_quality'] = sum(metrics.values()) / (len(metrics) - 1)
        
        return metrics
    
    def export_pipeline_result(self, result: PipelineResult, output_path: str):
        """Exporta resultado do pipeline para JSON"""
        
        export_data = {
            'pipeline_metadata': {
                'etapa_atual': result.etapa_atual,
                'processing_time': result.processing_time,
                'questoes_count': len(result.questoes_extraidas),
                'quality_metrics': result.quality_metrics
            },
            'questoes_estruturadas': [asdict(q) for q in result.questoes_extraidas],
            'segmentos': result.segmentos,
            'embeddings_count': len(result.embeddings),
            'pipeline_stats': {
                'texto_bruto_length': len(result.texto_bruto),
                'texto_limpo_length': len(result.texto_limpo),
                'segmentos_count': len(result.segmentos)
            }
        }
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False)
        
        logger.info(f"üìÅ Pipeline result exportado: {output_path}")

def demonstrar_pipeline():
    """Demonstra√ß√£o do pipeline completo"""
    print("üöÄ PIPELINE ENEM - SISTEMA ESTRUTURADO EM 6 ETAPAS")
    print("="*70)
    print("üìã Seguindo metodologia sugerida:")
    print("   1. Extra√ß√£o: PDF ‚Üí texto bruto (pdfplumber)")
    print("   2. Limpeza: remover headers, footers, numera√ß√£o")  
    print("   3. Segmenta√ß√£o: identificar in√≠cio/fim de quest√µes")
    print("   4. Estrutura√ß√£o: organizar em formato JSON")
    print("   5. Embedding: vetorizar conte√∫do relevante")
    print("   6. Retrieval: preparar busca estruturada")
    print()
    
    # Inicializar sistema
    pipeline = ENEMPipelineSystem()
    
    # Executar pipeline
    result = pipeline.executar_pipeline_completo("exemplo_enem.pdf")
    
    # Mostrar resultados
    print("üìä RESULTADOS DO PIPELINE:")
    print("="*50)
    print(f"‚è±Ô∏è Tempo de processamento: {result.processing_time:.2f}s")
    print(f"üìÑ Quest√µes extra√≠das: {len(result.questoes_extraidas)}")
    print(f"‚úÇÔ∏è Segmentos criados: {len(result.segmentos)}")
    print(f"üß† Embeddings gerados: {len(result.embeddings)}")
    print(f"‚≠ê Qualidade geral: {result.quality_metrics['overall_quality']:.2f}")
    print()
    
    # Mostrar quest√µes estruturadas
    print("üìù QUEST√ïES ESTRUTURADAS:")
    print("-" * 40)
    for i, questao in enumerate(result.questoes_extraidas[:2]):  # Mostrar apenas 2
        print(f"üî¢ Quest√£o {questao.numero}")
        print(f"   üìö √Årea: {questao.area_conhecimento}")
        print(f"   üéØ Assunto: {questao.assunto}")
        print(f"   üìù Enunciado: {questao.enunciado[:100]}...")
        print(f"   üî§ Alternativas: {len(questao.alternativas)}")
        print(f"   ‚ö° Embedding: {len(result.embeddings.get(questao.embedding_key, []))} dims")
        print()
    
    # Exportar resultado
    pipeline.export_pipeline_result(result, "pipeline_enem_result.json")
    
    print("‚úÖ PIPELINE DEMONSTRADO COM SUCESSO!")
    print("üéâ Sistema pronto para integra√ß√£o RAG!")

def main():
    """Fun√ß√£o principal"""
    demonstrar_pipeline()

if __name__ == "__main__":
    main() 